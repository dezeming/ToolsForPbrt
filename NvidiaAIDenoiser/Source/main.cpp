/**
Copyright (C) <2023>  <Dezeming>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

// ======================================================================== //
// Copyright 2018-2019 Ingo Wald                                            //
//                                                                          //
// Licensed under the Apache License, Version 2.0 (the "License");          //
// you may not use this file except in compliance with the License.         //
// You may obtain a copy of the License at                                  //
//                                                                          //
//     http://www.apache.org/licenses/LICENSE-2.0                           //
//                                                                          //
// Unless required by applicable law or agreed to in writing, software      //
// distributed under the License is distributed on an "AS IS" BASIS,        //
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. //
// See the License for the specific language governing permissions and      //
// limitations under the License.                                           //
// ======================================================================== //

#include "SampleRenderer.h"

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include "3rdParty/stb_image_write.h"

#include "exrLoad.h"
#include "exrSaver.h"

namespace PbrtOptixDenoiser {
  
 // input: .exr file generated by pbrt
 /*! initialize optix, denoise an Image with G-Buffers generated from PBRT */
 extern "C" int main(int ac, char **av)
  {
    try {
        
        // Test code for single denoised result, including exporting visualized Albedo/Normal/Position
        if (1) {
            // Should Albedo be removed before filtering
            bool illumOnly = false;
            bool saveOriginFile = false;
            bool saveDenoisedFile = false;

            FilterOptions filterOptions;
            filterOptions.useAlbedo = true;
            filterOptions.useNormal = true;
            ExrDataStructure datastruct;
            gdt::vec2i ImageSize;

            SampleDenoiser denoiser(illumOnly, filterOptions);

            // input
            std::string inputFilename;
            // output
            std::string outputDir;

            if (0) {
                inputFilename = "D:/Develop/PBRT_Dez/Build/Save/Scene3-Fast/temporal-N5/1.exr";
                outputDir = "D:/Develop/PBRT_Dez/Build/Save/Scene3-Fast/temporal-N5-Denoised/";
            }

            inputFilename = "./TestFile/frames00016.exr";
            outputDir = "./TestFile/";

            // .png files
            std::string originExrFile;
            std::string denoised2ExrFile;
            // .exr files
            std::string undenoisedFile;
            std::string denoisedFile;
            std::string neighbourClamppedFile;
            std::string denoised2File;
            std::string albedoFile;
            std::string normalFile;
            std::string positionFile;

            originExrFile = outputDir + "originFile.exr";
            denoised2ExrFile = outputDir + "denoised2.exr";

            undenoisedFile = outputDir + "undenoisedFile.png";
            denoisedFile = outputDir + "denoisedFile.png";
            neighbourClamppedFile = outputDir + "neighbourClamppedFile.png";
            denoised2File = outputDir + "denoised2File.png";
            albedoFile = outputDir + "albedo.png";
            normalFile = outputDir + "normal.png";
            positionFile = outputDir + "position.png";

            // loading image pointer for. exr
            datastruct.clear();
            int loadInfo = exrLoad::loadGBuffers(inputFilename, ImageSize, datastruct, illumOnly);
            if (loadInfo != 0) return loadInfo;

            // Initialize the denoiser and load to CPU memory
            denoiser.resize(ImageSize);
            denoiser.loadCpuBuffer(datastruct);

            // Start denoising
            denoiser.render();
            // Load and save as rgba 32-bit data
            uint32_t* denoisedOutput = new uint32_t[ImageSize.x * ImageSize.y];
            denoiser.downloadPixels(denoisedOutput);
            stbi_write_png(denoisedFile.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));
            denoiser.downloadUndenoisedPixels(denoisedOutput);
            stbi_write_png(undenoisedFile.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));
            denoiser.downloadNeighbourClamppedPixels(denoisedOutput);
            stbi_write_png(neighbourClamppedFile.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));

            // Generate the results of the second iterative filtering
            denoiser.render2();
            denoiser.downloadRender2Pixels(denoisedOutput);
            stbi_write_png(denoised2File.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));

            exrLoad::AlbedoVisualize(datastruct, denoisedOutput, false);
            stbi_write_png(albedoFile.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));
            exrLoad::NormalVisualize(datastruct, denoisedOutput);
            stbi_write_png(normalFile.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));
            exrLoad::PositionVisualize(datastruct, denoisedOutput);
            stbi_write_png(positionFile.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));


            // Save the denoised result to an. exr file
            if (saveOriginFile) {
                int saveInfo = exrLoad::float2exr(originExrFile, datastruct, ImageSize);
            }

            if (saveDenoisedFile) {
                denoiser.downloadDenoised2FloatBuffer(datastruct);
                int saveInfo = exrLoad::float2exr(denoised2ExrFile, datastruct, ImageSize);
            }

            // Release CPU memory
            delete[] denoisedOutput;
            datastruct.clear();

        }


        // Denoising an image sequence
        if (0) {

            // Should Albedo be removed before filtering
            bool illumOnly = false;
            bool saveOriginFile = false;
            bool saveDenoisedFile = false;

            FilterOptions filterOptions;
            //flterOptions.useAlbedo = true;
            //flterOptions.useNormal = true;

            SampleDenoiser denoiser(illumOnly, filterOptions);
            ExrDataStructure datastruct;

            gdt::vec2i ImageSize;

            for (int imageIndex = 0; imageIndex < 300; imageIndex++) {

                datastruct.clear();

                std::string frameID =   
                    std::to_string(imageIndex/10000) + 
                    std::to_string(imageIndex % 10000 / 1000) + 
                    std::to_string(imageIndex % 1000 / 100) + 
                    std::to_string(imageIndex % 100 / 10) + 
                    std::to_string(imageIndex % 10);
                frameID = std::to_string(imageIndex);

                // input
                //std::string inputFilename = "D://Develop/PBRT_Dez/Build/Save/Scene3-Fast/frames/frames" + frameID + ".exr";
                // output
                // std::string denoised2File = "D://Develop/PBRT_Dez/Build/Save/Scene3-Fast/denoised/" + frameID + ".png";
                
                // input
                std::string inputFilename;
                // output
                std::string undenoisedFile;
                std::string denoisedFile;
                std::string neighbourClamppedFile;
                std::string denoised2File;
                // exr file
                std::string originExrFile;
                std::string denoised2ExrFile;
                
                std::string imagesfolderInput = "D:/Datasets-Generated/JournalVideo/frames-out-0.7/";
                std::string imagesfolderOutput = "D:/Datasets-Generated/JournalVideo/frames-out-0.7-denoised/";
                inputFilename = imagesfolderInput + frameID + ".exr";
                // output      
                undenoisedFile = imagesfolderOutput + "undenoisedFile.png";
                denoisedFile = imagesfolderOutput + "denoisedFile.png";
                neighbourClamppedFile = imagesfolderOutput + "neighbourClamppedFile.png";
                denoised2File = imagesfolderOutput + frameID + ".png";

                originExrFile = imagesfolderOutput + "originFile.exr";
                denoised2ExrFile = imagesfolderOutput + "denoised2.exr";

                // loading image pointer for. exr
                int loadInfo = exrLoad::loadGBuffers(inputFilename, ImageSize, datastruct, illumOnly);
                if (loadInfo != 0) return loadInfo;
                
                // Initialize the denoiser and load to CPU memory
                denoiser.resize(ImageSize);
                denoiser.loadCpuBuffer(datastruct);

                // Start denoising
                denoiser.render();

                // Load and save as rgba 32-bit data
                uint32_t* denoisedOutput = new uint32_t[ImageSize.x * ImageSize.y];

                if (0) {
                    denoiser.downloadPixels(denoisedOutput);
                    stbi_write_png(denoisedFile.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));
                    denoiser.downloadUndenoisedPixels(denoisedOutput);
                    stbi_write_png(undenoisedFile.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));
                    denoiser.downloadNeighbourClamppedPixels(denoisedOutput);
                    stbi_write_png(neighbourClamppedFile.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));
                }

                // Generate the results of the second iterative filtering
                denoiser.render2();
                denoiser.downloadRender2Pixels(denoisedOutput);
                stbi_write_png(denoised2File.c_str(), ImageSize.x, ImageSize.y, 4, denoisedOutput, ImageSize.x * sizeof(uint32_t));

                // Save the origin file to an. exr file (just a test)
                if (saveOriginFile) {
                    int saveInfo = exrLoad::float2exr(originExrFile, datastruct, ImageSize);
                }
                // Save the denoised result to an.exr file
                if (saveDenoisedFile) {
                    denoiser.downloadDenoised2FloatBuffer(datastruct);
                    int saveInfo = exrLoad::float2exr(denoised2ExrFile, datastruct, ImageSize);
                }

                // Release CPU memory
                delete[] denoisedOutput;
                datastruct.clear();
            }

        }


        // Extract and convert the R/G/B three channels from .exr file into LDR values, and save them in png
        if (0) {

            // input
            std::string filename = "./DataDir/5spp.exr";
            // output
            std::string outfile = "./DataDir/output.png";

            SampleConvertor convertor;
            gdt::vec2i ImageSize;

            std::vector<float4*> dataPointers;
            // dataPointers: RGB
            int loadInfo = exrLoad::loadRGB(filename, ImageSize, dataPointers);
            if (loadInfo != 0) return loadInfo;
            
            if (dataPointers.size() != 1) return -1;

            convertor.resize(ImageSize);
            convertor.loadCpuBuffer(dataPointers[0]);
            convertor.convert();

            uint32_t* convertOutput = new uint32_t[ImageSize.x * ImageSize.y];

            convertor.downloadPixels(convertOutput);
            stbi_write_png(outfile.c_str(), ImageSize.x, ImageSize.y, 4, convertOutput, ImageSize.x * sizeof(uint32_t));

            for (int i = 0; i < dataPointers.size(); i++) {
                delete dataPointers[i];
                dataPointers[i] = nullptr;
            }
            delete[] convertOutput;

        }


        } catch (std::runtime_error& e) {
        std::cout << GDT_TERMINAL_RED << "FATAL ERROR: " << e.what()
                << GDT_TERMINAL_DEFAULT << std::endl;
        std::cout << "Did you forget to copy sponza.obj and sponza.mtl into your optix7course/models directory?" << std::endl;
        exit(1);
        }
        return 0;
  }
  
} // ::osc
